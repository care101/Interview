# static

- static的作用主要有两种:第一个作用是限定作用域；第二个作用是保持变量内容持久化；

>> c语言中static的用法：

  - 1、全局静态变量：静态存储区，在整个程序运行期间一直存在。未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - 2、局部静态变量：静态存储区；未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
  - 3、静态函数：在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

>> c++中static的用法：
　
  - 1、类的静态成员：在程序的全局数据区分配，定义时要分配空间，所以不能在类声明中定义
 ```C++
  class A{
　　   private:
　　　     static int val;
　　};
 ``` 
   在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝；
   
   - 2、类的静态成员函数：静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例，静态成员函数主要用于对静态数据成员的操作。静态成员函数和静态数据成员都没有this指针。
```C++
  class A{
　　    private:
　　　　    static int func(int x);
　　};
```
　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；
```C++
　　void  A::func(int);
```
　　静态成员函数可以继承和覆盖，但无法是虚函数；
  
- 3、只在cpp内有效的全局变量：在cpp文件的全局范围内声明：
```C++
　　static int val = 0；
```
　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；
  
 - 4、只在cpp内有效的全局函数：函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；`warning：`不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
 
 # explicit
 
 - 关键字的作用（防止隐性转换和拷贝初始化，然后举拷贝初始化失败的一个例子）

 - explicit关键字的作用就是防止类构造函数的隐式自动转换.C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的.explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数. 
 
 # 内存分配方式 
 
 - 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区： 
 
>> 1）程序区：
 
   用于存储程序的代码，即程序的二进制代码。 
 
>> 2）静态存储区：
 
   用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了,这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
 
>> 3）动态存储区：
 
   用于在程序执行时分配的内存，又分为：堆区（heap）和栈区(stack)。
 
   - 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。分配方式类似于链表。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它。若程序员不释放，程序结束时可能由OS回收。否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。
 
   - 栈区:在函数执行时，函数内部的局部变量、函数参数、返回数据、返回地址等的存储单元的内存区域。其操作方式类似于数据结构中的栈。函数运行结束时，这些内存区域由编译器自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
   
 # 堆和栈的区别
 
  >> 申请方式和回收方式不同
  
 - 栈（英文名称是stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。

 - 堆（英文名称是heap）则是程序员根据需要自己申请的空间，例如malloc（10）；开辟十个字节的空间。堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。

  >> 申请后系统的响应
  
- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。
 
 >> 申请效率的比较
 
- 栈：由系统自动分配，速度较快。但程序员是无法控制的。
	
- 堆：是由new或malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
 
 >> 申请大小的限制
 
- 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
	
- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
 
 >> 堆和栈中的存储内容
 
- 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 

- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
 
 >> 存取效率的比较
```C++
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb"; 
```
- aaaaaaaaaaa是在运行时刻赋值的；放在栈中。 
- 而bbbbbbbbbbb是在编译时就确定的；放在堆中。

但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

   
   

