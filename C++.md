# static

- static的作用主要有两种:第一个作用是限定作用域；第二个作用是保持变量内容持久化；

>> c语言中static的用法：

  - 1、全局静态变量：静态存储区，在整个程序运行期间一直存在。未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - 2、局部静态变量：静态存储区；未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
  - 3、静态函数：在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

>> c++中static的用法：
　
  - 1、类的静态成员：在程序的全局数据区分配，定义时要分配空间，所以不能在类声明中定义
 ```C++
  class A{
　　   private:
　　　     static int val;
　　};
 ``` 
   在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝；
   
   - 2、类的静态成员函数：静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例，静态成员函数主要用于对静态数据成员的操作。静态成员函数和静态数据成员都没有this指针。
```C++
  class A{
　　    private:
　　　　    static int func(int x);
　　};
```
　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；
```C++
　　void  A::func(int);
```
　　静态成员函数可以继承和覆盖，但无法是虚函数；
  
- 3、只在cpp内有效的全局变量：在cpp文件的全局范围内声明：
```C++
　　static int val = 0；
```
　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；
  
 - 4、只在cpp内有效的全局函数：函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；`warning：`不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
 
 # explicit
 
 - 关键字的作用（防止隐性转换和拷贝初始化，然后举拷贝初始化失败的一个例子）

 - explicit关键字的作用就是防止类构造函数的隐式自动转换.C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的.explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数. 
 
 # printf
 
 printf("%s%d", s, d)的压栈情况，执行Printf函数时sp指针的变化。
sp就是堆栈指针，直接移动即可，注意堆栈是从高到底，相加相减分清楚。
printf函数的压栈顺序是从右到左压栈，计算表达式值的顺序也是从右到左，由于输入数据类型的多样性，压栈的时候将数据或数据的地址mov到寄存器中，然后将寄存器压栈。由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据第一个明确的参数确定下来，就可以使用不定参数，这也是C语言的一大特色。
printf函数怎么传参，printf("%d%d",i)会发生什么，为什么
 首先，变量将值传给计算机，计算机把它们放置到被称为堆栈（stack）的一块内存区域中来。计算机根据变量的类型而非转换说明符（like %c %f）把这些值放到堆栈中。然后，标识符根据读取数据的类型在stack中读取，并打印出来。

（函数的堆栈映像图，反序入栈，根据控制字符串，检索参数个数和参数类型）（会造成获取一个错误的参数，具体数据是不确定的）

 
 printf的格式化输出怎么实现的
int printf(const char *format,[argument])
{
  char printf_buf[1024];
  va_list args;
  int printed;

  va_start(args, fmt);
  printed = vsprintf(printf_buf, fmt, args);
  va_end(args);

  puts(printf_buf);

  return printed;
}
format 参数输出的格式，定义格式为：
　　%[flags][width][.perc] [F|N|h|l]type

 
 # 指针和引用
 
>> 相同点：

指针指向一块内存，而引用是一块内存的别名；

>> 不同点：

- 指针是一个实体，他在栈中有自己使用的空间，但是引用没有；

- 引用必须初始化，指针不用但是最好初始化

- 指针使用时必须加'*'然后解引用，引用不用；

- 引用只能初始化一次，指针不是；

- 引用不用const去修饰，但是指针可以，const 的指针不可变

- 指针和地址运用自增（++）不同，引用是值进行自增，而指针是地址进行自增；

- 引用不能为空，指针可以为空

- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小

>> 联系

- 引用的内部使用指针实现的（如何实现这里不做解释）

- 引用是受了限制的指针

# 链表，队列，堆栈的区别

主要区别是适用的地方不一样
  
>> 链表实际上可以认为是一种数据的物理组织形式, 是一种存储方式，是用指针或对象的引用组织起的一种数据的存储方式.它可以在非连续的内存空间里面存储一个集合的元素。和它对应的是数组，数组要在连续的空间里存储集合的元素
  
>> 队列和堆栈是一个更高层次的概念, 是一种特殊的数据组织形式。可以把他们看成是一系列的集合。其底层可以是用链表也可以是用数组来实现.   

 - [栈](https://github.com/care101/Interview/blob/master/C++.md#printf)的特点是先进后出，队列的特点是先进先出。   
 
 - 队列可以看成是有2个口的集合一个口叫队头一个叫队尾，只能在对头进行删除操作，在队尾做插入。根据这样的操作。队列特点是先进先出   
  
 - 堆栈可以看成是有1个口的集合，这个口叫栈顶。插入和删除操作只能在栈顶操作。根据这样的操作。堆栈的特点是是后进先出.   
  
# 数组和链表的区别
	
 >> 数组的特点：
 
 随机访问性强；查找速度快。插入和删除效率低；可能浪费内存；内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展。
	
 - 在内存中，数组是一块连续的区域。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。不利于扩展，数组定义的空间不够时要重新定义数组。
	
 >> 链表的特点：
 
 插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活；不能随机查找，必须从第一个开始遍历，查找效率低。
	
 - 在内存中可以存在任何地方，不要求连续。每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。增加数据和删除数据很容易。查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。不指定大小，扩展方便。链表大小不用定义，数据随意增删。


# C++动态性

动态性就是指在程序在运行的时候才能确定具体的功能；在c++中的动态性具体体现为类中的虚函数；虚基类；动态联编和多态性。

>> 虚函数

 虚函数就是在类中函数的前面加上关键字virtual，一旦一个类中的函数被申明为虚函数，那么它的子类中的对应函数也是虚函数，为了提高可读性，可以显示加上virtual关键字。

>> 抽象基类

抽象基类就是将类中的虚函数申明为纯虚函数，那么该类就是抽象类，抽象类不能实例化，其作用就是为了让其派生类继承它的接口。

![抽象基类](https://github.com/care101/Interview/blob/master/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB.png)

>> 动态联编

动态联编就是用基类的指针去调用子类中的对象，程序会在动态运行的时候决定调用哪个一个子类的函数。

![动态联编](https://github.com/care101/Interview/blob/master/%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96.png)

>> 多态

多个派生类一起继承了一个基类，每个派生类的对象都可以当成基类对象来使用，比如形参中当成基类对象。将虚函数和动态联编和在一起就成了多态。

# 封装

- 封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成类，其中数据和函数都是类的成员，目的在于将对象的使用者和设计者分开，以提高软件的可维护性和可修改性。
　　
>> 特性：

- 1.结合性，即是将属性和方法结合    

- 2.信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用    

- 3.实现代码重用

# 多态

> 动态多态：

运行期多态通过虚函数发生于运行期。对模板参数而言，多态是通过模板具现化和函数重载解析实现的。以不同的模板参数具现化导致调用不同的函数，这就是所谓的编译期多态。	

- 运行期多态的实现依赖于虚函数机制。
 
 当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现。

 >> 运行期多态优点

- 1.OO设计中重要的特性，对客观世界直觉认识。

- 2.能够处理同一个继承体系下的异质类集合。运行期多态的优势还在于它使处理异质对象集合称为可能：

 >> 运行期多态缺点

 - 1.运行期间进行虚函数绑定，提高了程序运行开销。
 
 - 2.庞大的类继承层次，对接口的修改易影响类继承层次。
 
 - 3.由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
 
 - 4.虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当值得付出的资源消耗，列为缺点有点勉强。

> 静态多态：

相比较于运行期多态，实现编译期多态的类之间并不需要成为一个继承体系，它们之间可以没有什么关系，但约束是它们都有相同的隐式接口。

 >> 编译期多态优点

 - 1.它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
 
 - 2.在编译器完成多态，提高运行期效率。
 
 - 3.具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。

 >> 编译期多态缺点

 - 1.程序可读性降低，代码调试带来困难。
  
 - 2.无法实现模板的分离编译，当工程很大时，编译时间不可小觑。

 - 3.无法处理异质对象集合。

# 继承

 
 # 内存分配方式 
 
> 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区： 
 
>> 程序区：
 
   用于存储程序的代码，即程序的二进制代码。 
 
>> 静态存储区：
 
   用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了,这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
 
>> 动态存储区：
 
   用于在程序执行时分配的内存，又分为：堆区（heap）和栈区(stack)。
 
   - 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。分配方式类似于链表。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它。若程序员不释放，程序结束时可能由OS回收。否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。
 
   - 栈区:在函数执行时，函数内部的局部变量、函数参数、返回数据、返回地址等的存储单元的内存区域。其操作方式类似于数据结构中的栈。函数运行结束时，这些内存区域由编译器自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
   
> 一个由C/C++编译的程序占用的内存分为以下几个部分:
 
>> 栈区（stack）

程序运行时由编译器自动分配，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。程序结束时由编译器自动释放。

>> 堆区（heap） 

在内存开辟另一块存储区域。一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

>> 全局区（静态区）（static）

编译器编译时即分配内存。全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

>> 文字常量区 

常量字符串就是放在这里的。 程序结束后由系统释放。

>> 程序代码区

存放函数体的二进制代码。

   
 # 堆和栈的区别
 
  >> 申请方式和回收方式不同
  
 - 栈（英文名称是stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。

 - 堆（英文名称是heap）则是程序员根据需要自己申请的空间，例如malloc（10）；开辟十个字节的空间。堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。

  >> 申请后系统的响应
  
- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。
 
 >> 申请效率的比较
 
- 栈：由系统自动分配，速度较快。但程序员是无法控制的。
	
- 堆：是由new或malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
 
 >> 申请大小的限制
 
- 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
	
- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
 
 >> 堆和栈中的存储内容
 
- 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 

- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
 
 >> 存取效率的比较
```C++
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb"; 
```
- aaaaaaaaaaa是在运行时刻赋值的；放在栈中。 

- 而bbbbbbbbbbb是在编译时就确定的；放在堆中。

但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

 # 如何减少频繁分配内存（malloc或者new）造成的内存碎片
 
 > 开辟内存池
 
- 针对特殊情况，例如需要频繁分配释放固定大小的内存对象时，不需要复杂的分配算法和多线程保护。也不需要维护内存空闲表的额外开销，从而获得较高的性能。

- 由于开辟一定数量的连续内存空间作为内存池块，因而一定程度上提高了程序局部性，提升了程序性能。

- 比较容易控制页边界对齐和内存字节对齐，没有内存碎片的问题。

- 当需要分配管理的内存在100M一下的时候，采用内存池会节省大量的时间，否则会耗费更多的时间。

- 内存池可以防止更多的内存碎片的产生

- 更方便于管理内存

>> 内存的分配：

- 如果分配大小超过1024，直接采用malloc分配，分配的时候多分配sizeof(size_t)字节，用于保存该块的大小；

- 否则根据分配大小，查找到容纳该大小的最小size的MemoryChunk；

- 查找MemoryChunk的链表指针pList，找到空闲的MemoryBlock返回；

- 如果pList为NULL，临时创建MemoryBlock返回；

- MemoryBlock头部包含两个成员，pChunk指向的所属的MemoryChunk对象，size表明大小，其后才是给用户使用的空间；

>> 内存的释放：

- 根据释放的指针，查找器size头部，即减去sizeof(size_t)字节，判断该块的大小；

- 如果大小超过1024，直接free;

- 否则交给MemoryChunk处理，而块的头部保存了该指针，因此直接利用该指针就可以收回该内存。

>> 注意的问题：

上述设计的内存池通过冗余的头部来实现内存块的分配与释放，减少了内存池的操作时间，速度上要优于原始的malloc和free操作，同时减少了内存碎片的增加。但是该设计中没有去验证释放的块冗余头部的正确性，因此故意释放不属于内存池中的块或者修改头部信息都会导致内存池操作失败，当然这些可以由程序员来控制。此外，内存池中分配出去的内存块如果不主动释放，内存池没有保留信息，不会自动释放，但是在退出的时候会验证验证是否完全释放，其实这个在系统测试时候就可以检测出来，我想这个缺陷也是可以弥补的，在此提出，希望使用者注意。

# 内存泄漏

 - 内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
 
 - 通常我们所说的内存泄漏，是指分配出去的内存在使用之后没有释放掉，没有回收，长此以往，会造成没有足够的内存可以分配。一般表现为运行时间越长，占用的内存越多，最终导致系统奔溃。 
	
 - 一般的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显式释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

 >> 一般来说内存泄漏有两种情况。
 
 - 一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）；
 
 - 另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。
 
 >> 内存泄漏的分类（按发生方式来分类）
 
 - 常发性内存泄漏。
 
 发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
	
 - 偶发性内存泄漏。
 
 发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
	
- 一次性内存泄漏。

发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
	
- 隐式内存泄漏。

程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
 
 >> 如何避免：
 
 - 第一，是在声明对象引用之前，明确内存对象的有效作用域。在一个函数内有效的内存对象，应该声明为 local 变量，与类实例生命周期相同的要声明为实例变量……以此类推。
 
 - 第二，在内存对象不再需要时，记得手动将其引用置空。
 
# 内存溢出

 - 内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 

 >> 内存溢出原因：
 
 - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 

 - 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 

 - 代码中存在死循环或循环产生过多重复的对象实体； 

 - 使用的第三方软件中的BUG； 

 - 启动参数内存值设定的过小

 >> 内存溢出的解决方案： 

 - 第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
 
 - 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

 - 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
 
 - 第四步，使用内存查看工具动态查看内存使用情况。

>> 重点排查以下几点： 

 - 1.检查对数据库查询中，是否有一次获得全部数据的查询。
 
 一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

 - 2.检查代码中是否有死循环或递归调用。
 
 - 3.检查是否有大循环重复产生新对象实体。

 - 4.检查对数据库查询中，是否有一次获得全部数据的查询。
 
 一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

 - 5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。


# 内存泄漏与内存溢出的关系

 - 内存泄漏的堆积最终会导致内存溢出；
 
 - 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误；
 
 - 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。
 
 - 比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。

  
   

