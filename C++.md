# static

- static的作用主要有两种:第一个作用是限定作用域；第二个作用是保持变量内容持久化；

>> c语言中static的用法：

  - 1、全局静态变量：静态存储区，在整个程序运行期间一直存在。未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - 2、局部静态变量：静态存储区；未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
  - 3、静态函数：在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

>> c++中static的用法：
　
  - 1、类的静态成员：在程序的全局数据区分配，定义时要分配空间，所以不能在类声明中定义
 ```C++
  class A{
　　   private:
　　　     static int val;
　　};
 ``` 
   在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝；
   
   - 2、类的静态成员函数：静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例，静态成员函数主要用于对静态数据成员的操作。静态成员函数和静态数据成员都没有this指针。
```C++
  class A{
　　    private:
　　　　    static int func(int x);
　　};
```
　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；
```C++
　　void  A::func(int);
```
　　静态成员函数可以继承和覆盖，但无法是虚函数；
  
- 3、只在cpp内有效的全局变量：在cpp文件的全局范围内声明：
```C++
　　static int val = 0；
```
　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；
  
 - 4、只在cpp内有效的全局函数：函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；`warning：`不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
 
 # explicit
 
 - 关键字的作用（防止隐性转换和拷贝初始化，然后举拷贝初始化失败的一个例子）

 - explicit关键字的作用就是防止类构造函数的隐式自动转换.C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的.explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数. 
 
 # 内存分配方式 
 
 - 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区： 
 
1）程序区：用于存储程序的代码，即程序的二进制代码。 
2）静态存储区：用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了。 
3）动态存储区：用于在程序执行时分配的内存，又分为：堆区（heap）和栈区(stack)。堆区：用于动态内存分配，程序运行时由内存分配函数在堆上分配内存。在C语言中，只能使用指针才能动态的分配内存。栈区:在函数执行时，函数内部的局部变量和函数参数的存储单元的内存区域，函数运行结束时，这些内存区域会自动释放。
    内存分配方式有三种：
    [1]从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
    [2]在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
[3]从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

