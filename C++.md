# static

- static的作用主要有两种:第一个作用是限定作用域；第二个作用是保持变量内容持久化；

>> c语言中static的用法：

  - 1、全局静态变量：静态存储区，在整个程序运行期间一直存在。未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
  - 2、局部静态变量：静态存储区；未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
  - 3、静态函数：在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

>> c++中static的用法：
　
  - 1、类的静态成员：在程序的全局数据区分配，定义时要分配空间，所以不能在类声明中定义
 ```C++
  class A{
　　   private:
　　　     static int val;
　　};
 ``` 
   在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝；
   
   - 2、类的静态成员函数：静态成员函数与类相联系，不与类的对象相联系。静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例，静态成员函数主要用于对静态数据成员的操作。静态成员函数和静态数据成员都没有this指针。
```C++
  class A{
　　    private:
　　　　    static int func(int x);
　　};
```
　　 实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；
```C++
　　void  A::func(int);
```
　　静态成员函数可以继承和覆盖，但无法是虚函数；
  
- 3、只在cpp内有效的全局变量：在cpp文件的全局范围内声明：
```C++
　　static int val = 0；
```
　　这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；
  
 - 4、只在cpp内有效的全局函数：函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；`warning：`不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
 
 # explicit
 
 - 关键字的作用（防止隐性转换和拷贝初始化，然后举拷贝初始化失败的一个例子）

 - explicit关键字的作用就是防止类构造函数的隐式自动转换.C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的.explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数. 
 
 # 指针和引用
 
>> 相同点：

指针指向一块内存，而引用是一块内存的别名；

>> 不同点：

- 指针是一个实体，他在栈中有自己使用的空间，但是引用没有；

- 引用必须初始化，指针不用但是最好初始化

- 指针使用时必须加'*'然后解引用，引用不用；

- 引用只能初始化一次，指针不是；

- 引用不用const去修饰，但是指针可以，const 的指针不可变

- 指针和地址运用自增（++）不同，引用是值进行自增，而指针是地址进行自增；

- 引用不能为空，指针可以为空

- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小

>> 联系

- 引用的内部使用指针实现的（如何实现这里不做解释）

- 引用是受了限制的指针

 
 # 内存分配方式 
 
> 在C语言中，根据数据在内存中存在的时间（生存周期）不同，将内存空间分为三个区： 
 
>> 程序区：
 
   用于存储程序的代码，即程序的二进制代码。 
 
>> 静态存储区：
 
   用于存储全局变量和静态变量，这些变量的空间在程序编译时就已经分配好了,这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
 
>> 动态存储区：
 
   用于在程序执行时分配的内存，又分为：堆区（heap）和栈区(stack)。
 
   - 堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。分配方式类似于链表。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它。若程序员不释放，程序结束时可能由OS回收。否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。
 
   - 栈区:在函数执行时，函数内部的局部变量、函数参数、返回数据、返回地址等的存储单元的内存区域。其操作方式类似于数据结构中的栈。函数运行结束时，这些内存区域由编译器自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
   
> 一个由C/C++编译的程序占用的内存分为以下几个部分:
 
>> 栈区（stack）

程序运行时由编译器自动分配，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。程序结束时由编译器自动释放。

>> 堆区（heap） 

在内存开辟另一块存储区域。一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

>> 全局区（静态区）（static）

编译器编译时即分配内存。全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

>> 文字常量区 

常量字符串就是放在这里的。 程序结束后由系统释放。

>> 程序代码区

存放函数体的二进制代码。

   
 # 堆和栈的区别
 
  >> 申请方式和回收方式不同
  
 - 栈（英文名称是stack）是系统自动分配空间的，例如我们定义一个 char a；系统会自动在栈上为其开辟空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。

 - 堆（英文名称是heap）则是程序员根据需要自己申请的空间，例如malloc（10）；开辟十个字节的空间。堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。

  >> 申请后系统的响应
  
- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

- 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。
 
 >> 申请效率的比较
 
- 栈：由系统自动分配，速度较快。但程序员是无法控制的。
	
- 堆：是由new或malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
 
 >> 申请大小的限制
 
- 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
	
- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
 
 >> 堆和栈中的存储内容
 
- 栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 

- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
 
 >> 存取效率的比较
```C++
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb"; 
```
- aaaaaaaaaaa是在运行时刻赋值的；放在栈中。 

- 而bbbbbbbbbbb是在编译时就确定的；放在堆中。

但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

 # 如何减少频繁分配内存（malloc或者new）造成的内存碎片
 
 > 开辟内存池
 
- 针对特殊情况，例如需要频繁分配释放固定大小的内存对象时，不需要复杂的分配算法和多线程保护。也不需要维护内存空闲表的额外开销，从而获得较高的性能。

- 由于开辟一定数量的连续内存空间作为内存池块，因而一定程度上提高了程序局部性，提升了程序性能。

- 比较容易控制页边界对齐和内存字节对齐，没有内存碎片的问题。

- 当需要分配管理的内存在100M一下的时候，采用内存池会节省大量的时间，否则会耗费更多的时间。

- 内存池可以防止更多的内存碎片的产生

- 更方便于管理内存

>> 内存的分配：

- 如果分配大小超过1024，直接采用malloc分配，分配的时候多分配sizeof(size_t)字节，用于保存该块的大小；

- 否则根据分配大小，查找到容纳该大小的最小size的MemoryChunk；

- 查找MemoryChunk的链表指针pList，找到空闲的MemoryBlock返回；

- 如果pList为NULL，临时创建MemoryBlock返回；

- MemoryBlock头部包含两个成员，pChunk指向的所属的MemoryChunk对象，size表明大小，其后才是给用户使用的空间；

>> 内存的释放：

- 根据释放的指针，查找器size头部，即减去sizeof(size_t)字节，判断该块的大小；

- 如果大小超过1024，直接free;

- 否则交给MemoryChunk处理，而块的头部保存了该指针，因此直接利用该指针就可以收回该内存。

>> 注意的问题：

上述设计的内存池通过冗余的头部来实现内存块的分配与释放，减少了内存池的操作时间，速度上要优于原始的malloc和free操作，同时减少了内存碎片的增加。但是该设计中没有去验证释放的块冗余头部的正确性，因此故意释放不属于内存池中的块或者修改头部信息都会导致内存池操作失败，当然这些可以由程序员来控制。此外，内存池中分配出去的内存块如果不主动释放，内存池没有保留信息，不会自动释放，但是在退出的时候会验证验证是否完全释放，其实这个在系统测试时候就可以检测出来，我想这个缺陷也是可以弥补的，在此提出，希望使用者注意。

# 内存泄漏

 - 内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
 
 - 通常我们所说的内存泄漏，是指分配出去的内存在使用之后没有释放掉，没有回收，长此以往，会造成没有足够的内存可以分配。一般表现为运行时间越长，占用的内存越多，最终导致系统奔溃。 
	
 - 一般的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显式释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

 >> 一般来说内存泄漏有两种情况。
 
 - 一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）；
 
 - 另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。
 
 >> 内存泄漏的分类（按发生方式来分类）
 
 - 常发性内存泄漏。
 
 发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
	
 - 偶发性内存泄漏。
 
 发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
	
- 一次性内存泄漏。

发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
	
- 隐式内存泄漏。

程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
 
 >> 如何避免：
 
 - 第一，是在声明对象引用之前，明确内存对象的有效作用域。在一个函数内有效的内存对象，应该声明为 local 变量，与类实例生命周期相同的要声明为实例变量……以此类推。
 
 - 第二，在内存对象不再需要时，记得手动将其引用置空。
 
# 内存溢出

 - 内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 

 >> 内存溢出原因：
 
 - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 

 - 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 

 - 代码中存在死循环或循环产生过多重复的对象实体； 

 - 使用的第三方软件中的BUG； 

 - 启动参数内存值设定的过小

 >> 内存溢出的解决方案： 

 - 第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
 
 - 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

 - 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
 
 - 第四步，使用内存查看工具动态查看内存使用情况。

>> 重点排查以下几点： 

 - 1.检查对数据库查询中，是否有一次获得全部数据的查询。
 
 一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

 - 2.检查代码中是否有死循环或递归调用。
 
 - 3.检查是否有大循环重复产生新对象实体。

 - 4.检查对数据库查询中，是否有一次获得全部数据的查询。
 
 一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

 - 5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。


# 内存泄漏与内存溢出的关系

 - 内存泄漏的堆积最终会导致内存溢出；
 
 - 内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误；
 
 - 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。
 
 - 比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。

  
   

