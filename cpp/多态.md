目录

> [多态](https://github.com/care101/Interview/new/master/cpp#%E5%A4%9A%E6%80%81)

>> [静态多态（函数和运算符重载）](https://github.com/care101/Interview/new/master/cpp#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81)

>>> [重载](https://github.com/care101/Interview/new/master/cpp#%E9%87%8D%E8%BD%BD)

>>[动态多态（重写虚函数）](https://github.com/care101/Interview/new/master/cpp#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81)

>>> [重写](https://github.com/care101/Interview/new/master/cpp#%E9%87%8D%E5%86%99)

>>> [虚函数](https://github.com/care101/Interview/blob/master/cpp/%E5%A4%9A%E6%80%81.md#%E8%99%9A%E5%87%BD%E6%95%B0)

>>> [纯虚函数（java接口）]()


# 多态

是面向对象三大特征之一，另外两个是封装和继承。封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用。

多态从系统实现的角度来讲可以划分为两类：静态多态（也叫编译时多态性）和动态多态（又称运行时多态性），以前学过的函数重载和运算符的重载属于静态多态性，在程序编译时就能决定调用的是哪一个函数，静态多态是通过函数的重载来实现的（运算符重载实际上也属于函数的重载）。动态多态性是程序运行过程中才动态地确定操作所针对的对象，运行时多态性是通过虚函数来实现的。

## 静态多态

静态多态：编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。函数的地址在编译期就绑定了。

### 重载

#### 函数重载
  
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。

> 不能仅通过返回类型的不同来重载函数

C++调用一个函数是可以忽略其返回值的，这种情况下编译器就无法根据返回值类型来确定调用哪一个函数。保持解析操作符或函数调用时，独立于上下文（不依赖于上下文）如果返回类型考虑到函数重载中，这样将不可能再独立于上下文决定调用哪个函数。

> 编译器如何识别函数重载

编译后将一个重载函数的签名映射到一个新的标识：作用域+返回类型+函数名+参数列表

#### 运算符重载

函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

> 不能重载的操作符 

成员选择符.          

域解析运算符::            

对象选择符.*             

条件运算符: ？            

长度运算符sizeof  

> 提示：

C++中有许多运算符，比如=（等号）和 >>，只能作为member function被重载，也就是说，必须在类的定义里声明一下；同时的，也有些运算符，比如+（加号），可以既作为 member function 又作为non-member function被重载。

如果把运算符作为成员函数重载，那么类对象必须出现在运算符的左边。

1.一元操作符可以是不带参数的成员函数或带一个参数的非成员函数。

2.二元操作符可以是带一个参数的成员函数或带两个参数的非成员函数。

3.operator=、operator[]、operator()、operator->只能定义为成员函数。（这里其实调用赋值运算符时候是隐式绑定了一个*this来操作，同时，如果声明为友元，那么参数为两个，如果第一个参数是数，那么会导致 int 1=xxx，实际上，这样的情况是不允许的。） 

4.operator->的返回值必须是一个指针或能使用->的对象。

5.重载 operator++ 和 operator-- 时带一个 int 参数表示后缀，不带参数表示前缀。

## 动态多态

在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。使用virtual关键字修饰类的成员函数时，指明该函数为虚函数，派生类需要重新实现，编译器将实现动态绑定。

对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。操作函数通过指向基类的引用或指针来操作这些对象，由于有了虚函数，因此动态多态是在运行时完成的，也可以叫做运行期多态。

运行期多态通过虚函数发生于运行期。使用时在父类中写一个虚函数，在子类中分别重写，用这个父类指针调用这个虚函数，它实际上会调用各自子类重写的虚函数。运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现。

### 重写

重写（覆盖)是指派生类函数覆盖基类函数，子类重新定义父类中有相同名称和参数的虚函数。函数特征相同。但是具体实现不同，主要是在继承关系中出现的。

> 特征是：

 a 不同的范围，分别位于基类和派生类中
 
 b 函数的名字相同
 
 c 参数相同
 
 d 基类函数必须有virtual关键字
 
 e 返回值相同（或是协变），否则报错；
 
 f 重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的

> 重写需要注意：

1、被重写的函数不能是static的。必须是virtual的

2、重写函数必须有相同的类型，名称和参数列表,否则不能称其为重写而是重载.

3、重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的。重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public>protected>default>private）。被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没s有对其进行重写。

4、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；

5、重写的方法的返回值必须和被重写的方法的返回一致；

6、静态方法不能被重写为非静态的方法（会编译出错）。

#### 虚函数

C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。

虚函数的定义要遵循以下重要规则： 

1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。 

2.只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。 

3.静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。 

4.内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。 

5.构造函数不能是虚函数，因为构造的时候，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。 

6.析构函数可以是虚函数,而且通常声名为虚函数。

#### 纯虚函数

当函数没有实现方法或者需要子类来定义实现方法的时候，可以在父类中定义纯虚函数。当不同的子类继承这个父类的时候，定义不同的实现方法，那么实例化这个子类的时候，这个纯虚函数就有了不同的方法。这也解释了为什么包含纯虚函数的抽象类为什么不能实例化，因为它中间有函数根本不知道是怎么个实现！纯虚函数在基类中是没有定义的，必须在子类中加以实现。

C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。C++中的纯虚函数也是一种“运行时多态”。

> 总结：

1.虚函数必须实现，不实现编译器会报错。

2.父类和子类都有各自的虚函数版本。由多态方式在运行时动态绑定。

3.通过作用域运算符可以强行调用指定的虚函数版本。

4.纯虚函数声明如下：virtual void funtion()=0; 纯虚函数无需定义。包含纯虚函数的类是抽象基类，抽象基类不能创建对象，但可以声明指向抽象基类的指针或引用。

5.派生类实现了纯虚函数以后，该纯虚函数在派生类中就变成了虚函数，其子类可以再对该函数进行覆盖。

6.析构函数通常应该是虚函数，这样就能确保在析构时调用正确的析构函数版本。

> 用法区别：

1.虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类(abstract class)，而只含有虚函数的类(class)不能被称为抽象类(abstract class)。

2.虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。

3.虚函数和纯虚函数都可以在子类(sub class)中被重载，以多态的形式被调用。

4.虚函数和纯虚函数通常存在于抽象基类(abstract base class -ABC)之中，被继承的子类重载，目的是提供一个统一的接口。

5.虚函数的定义形式：virtual {method body} 纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样。

6.虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall
ClassName::virtualFunctionName(void)"

7.对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

8.实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

9.虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数

10.如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类(ABC)是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。



