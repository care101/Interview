# 秋招提前批

## 1、设计模式（单例模式）

## 2、类和结构体的差别

如果没有标明成员函数或者成员变量的访问权限级别，struct中默认是public，class默认private。

C#中如果没有标明成员函数或者成员变量的访问权限级别，struct和class都是private。区别是struct定义的是值类型，值类型的实例在栈上分配内存；class定义的是引用类型，引用类型的实例在堆上分配内存。

## 3、malloc和new的区别（面向对象的区别 ： new有构造函数）

> 属性

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

> 参数

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

> 返回类型

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

> 分配失败

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

> 自定义类型

new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

> 重载

C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

> 内存区域

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

> 线程安全

malloc函数是一个我们经常使用的函数，如果不对会造成一些潜在的问题。下面就malloc函数的线程安全性和可重入性做一些分析。我们知道一个函数要做到线程安全，需要解决多个线程调用函数时访问共享资源的冲突。而一个函数要做到可重入，需要不在函数内部使用静态或全局数据，不返回静态或全局数据，也不调用不可重入函数。

malloc函数线程安全但是不可重入的，因为malloc函数在用户空间要自己管理各进程共享的内存链表，由于有共享资源访问，本身会造成线程不安全。为了做到线程安全，需要加锁进行保护。同时这个锁必须是递归锁，因为如果当程序调用malloc函数时收到信号，在 信号处理函数 里再调用malloc函数，如果使用一般的锁就会造成死锁（信号处理函数中断了原程序的执行），所以要使用递归锁。虽然使用递归锁能够保证malloc函数的线程安全性，但是不能保证它的可重入性。按上面的场景，程序调用malloc函数时收到信号，在信号处理函数里再调用malloc函数就可能破坏共享的内存链表等资源，因而是不可重入的。至于malloc函数访问内核的共享数据结构可以正常的加锁保护，因为一个进程程调用malloc函数进入内核时，必须等到返回用户空间前夕才能执行信号处理函数，这时内核数据结构已经访问完成，内核锁已释放，所以不会有问题。

## 4、指针常量和常量指针（指针可以++吗 ： 常量指针可以，指针常量不可以）

> const int *p

“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。注意，const int *p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。 另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是C++11新特性，用它比用NULL更安全些）。

*的右边没有限定成分，表明p就是我们熟悉的普通指针，p的内容（即值，也就是它指向的东西的地址）是可以改变的；*的左边是const int，表明p指向的东西是一个const的int，我们不能通过p来修改这个int,因为它是const的。

> int* const p

就是所谓的“本身是常量的指针”。关于“p本身不能修改但可以通过p修改其所指”这一点，我们在讲判断方法时已经说过，这里主要再说一下p的初始化。由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int* const p=&a，我们只要求a的地址是确定的，但a的值可以不确定。比如下面的代码是可行的

*的右边是const，表明p本身是const的，我们不能对p的内容进行修改（例如++p;是不可以的），*的左边是int，即p指向的东西是普通的int，我们可以通过p来修改它（例如 *p=100;是可以的）。

> const int* const p

就是所谓的“所指和本身都是常量的指针”。

*的右边是const，表明指针p本身是const的，*的左边是const int，表明p指向的int也是const的。即这种情况下，p本身不能修改，同时也不能通过p修改它所指向的那个int。

## 5、测cpu占用情况

## 6、查看系统负载

